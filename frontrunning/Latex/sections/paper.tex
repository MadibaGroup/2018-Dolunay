% !TEX root = ../main.tex

\section{Introduction} \label{sec:intro}

Blockchain technology enables decentralized applications (DApps) or smart contracts. Function calls (or transactions) to the DApp are processed by a decentralized network. Transactions are finalized in stages: they (generally) first relay around the network, then are selected by a miner and put into a valid block, and finally, the block is well-enough incorporated that is unlikely to be reorganized. Front-running is an attack where a malicious node observes a transaction after it is broadcast but before it is finalized, and attempts to have its own transaction confirmed before or instead of the observed transaction. 

The mechanics of front-running works on all DApps but front-running is not necessarily beneficial, depending on the DApp's internal logic and/or as any mitigations it might implement. Therefore, DApps need to be studied individually or in categories. This paper is a series of case studies of DApps deployed on Ethereum (a popular blockchain supporting DApps) from each category of the top 25 most active, based on user activity.\footnote{List of decentralized applications \url{https://DAppradar.com/DApps}} We do case studies on decentralized exchanges (\eg Bancor), crypto-collectibles (\eg CryptoKitties), gambling services (\eg Fomo3D), and decentralized name services (\eg Ethereum Name Service). We also study initial coin offerings (ICOs), which by happenstance, did not appear in the top 25 on our sample day. After a few hacking incidents of high valued smart contracts~\cite{siegel2016daohack}, ICOs started to implement restrictions and capped how much funds can be gathered. This scarcity of the initial coins made for a competition to incentivize big investors to get in and buy the tokens at a discounted price and sell them to latecomers on the open markets~\cite{zetzsche2018ico,li2018initial}. ICOs started to experiment with different \textit{fair} capping methods, such as reverse dutch auction and dynamic ceilings~\cite{kaal2017initial}. We show empirical evidence of a miner purchasing tokens ahead of other users in Status.im. Finally, proposals to eliminate or mitigate front-running from DApps are scattered across forums, proposed standards (called EIPs in Ethereum) and academic papers; we systemize them in the last section. 

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Preliminaries
% = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Preliminaries \& Related Work}

\subsection{Traditional Front-running} 
\label{sec:What is front-running?}

\emph{Front-running} is a course of action where someone benefits from early access to market information about upcoming transactions and trades, typically because of a privileged position along the transmission of this information and is applicable to both financial and non-financial systems. In traditional stock exchanges, floor traders might overhear a broker's negotiation with her client over a large purchase, and literally race the broker to buy first, potentially profiting when the large sale temporarily reduces the supply of the stock. A malicious broker might also front-run their own client's orders by purchasing stock for themselves between receiving the instruction to purchase from the client and actually executing the purchase (similar techniques can be used for large sell orders). Front-running is unethical and illegal in jurisdictions with mature securities regulation. 

Cases of front-running are sometimes difficult to distinguish from related concepts like insider trading and arbitrage. In front-running, a person sees a concrete transaction that is set to execute and reacts to it before it actually gets executed. If the person instead has access to more general privileged information that might predict future transactions, but is not reacting at the actual pending trades, we would classify this activity as insider trading. If the person reacts after the trade is executed, or information is made public, and profits from being the fastest to react, this is considered arbitrage and is legal and encouraged because it helps markets integrate new information into prices quickly.


%maybe move this to appendix
\subsection{Literature on Traditional Front-running}\label{traditionalFrontrunning}
Front-running originates on the Chicago Board Options Exchange (\textit{CBoE}) \cite{markham1988front}. The Securities Exchange Commission \textit{(SEC)} in 1977 defines it as: ``The practice of effecting an options transaction based upon non-public information regarding an impending block transaction\footnote{A block in the stock market is a large number of shares, 10\,000 or more, to sell which will heavily changes the price} in the underlying stock, in order to obtain a profit when the options market adjusts to the price at which the block trades.~\cite{sec1978optionsmarket}'' Self-regulating exchanges (\eg \textit{CBoE}) and the \textit{SEC} spent the ensuing years planning how to detect and outlaw front-running practices~\cite{markham1988front}. The \textit{SEC} stated: ``It seems evident that such behaviour on the part of persons with knowledge of imminent transactions which will likely affect the price of the derivative security constitutes an unfair use of such knowledge.\footnote{Securities Exchange Act Release No. 14156, November 19, 1977, (Letter from George A. Fitzsimmons, Secretary, Securities, and Exchange Commission to Joseph W. Sullivan, President  CBoE).}'' The \textit{CBoE} tried to educate their members on existing rules, however, differences in opinion regarding the unfairness of front-running activities, insufficient exchange rules and lack of a precise definition in this area resulted in no action~\cite{sec1978optionsmarket} until the SEC began regulation. We refer the reader interested in further details on this early regulatory history to Markham~\cite{markham1988front}. The first front-running policies applied only to certain option markets. In 2002, the rule was expanded to cover all security futures~\cite{finra_2002}. In 2012, it was expanded further with the new amendment, FINRA Rule 5270, to cover trading in options, derivatives, or other financial instruments overlying a security with only a few exceptions~\cite{sec2012frontrunning,finra_2012}.

\subsection{Background on Blockchain Front-running} \label{sec:Front Running on the Blockchains}

In one sense, blockchain technology (which was introduced via Bitcoin in 2008~\cite{nakamoto2008bitcoin}) strives to disintermediate certain central parties that participate in a transaction. However, blockchains also introduce new participants in the relaying and finalization (\ie mining) of transactions that can act as front-runners. Any user monitoring blockchain network transactions (\eg running a full node) can see an unconfirmed transactions and broadcast a reactionary transaction that might be confirmed ahead of the original transaction. For regular users to front-run others on the blockchain, they need to be well connected to other nodes on the network and listen to the network to monitor all transactions that are broadcast. On the Ethereum blockchain, users have to pay for the computations in a small amount of Ether called \textsf{gas}~\cite{AccountT67:online}. The price that users pay for transactions, \textsf{gasPrice}, can increase or decrease how quickly miners will execute them and include them within the blocks they mine. Once seeing two identical transactions with different transaction fees, a rational miner will prioritize the transaction that pays a higher gas price, due to limited space in the blocks. Therefore, any regular user who runs a full-node Ethereum client can front-run pending transactions by sending similar transaction with a higher gas price. Also, blockchain miners are the only parties who can decide on the order of transactions within a block they mine, they can easily intercept and reorder the transactions in their blocks, this in case of malicious reordering is known as \textsf{transaction reordering} attack. 

\subsection{Literature on Blockchain Front-running}

%make them more pointy, shorten it. mainly the first paragraph


Aune~\etal discuss how the lack of time priority between broadcasting a transaction and its validation by miners on a blockchain based system would lead to market information leakage~\cite{aune2017footprints}. They also propose a cryptographic approach, similar to commit and reveal (see Section~\ref{CommitmentScheme}) to prevent front-running. Malinova and Park discuss different design settings for financial markets and trading platforms on decentralized ledgers~\cite{malinova2017market}. They argue that blockchain brings new options of transparency which affects traders behaviour, especially in the presence of intermediary front-runners. They model indirect trading costs and use the economic literature on search and trading at decentralized exchanges in their design settings to make front-running costly and inefficient. Breidenbach~\etal~\cite{breidenbach2018enter} face the front-running issue in the context of automating bug bounties for smart contracts. Upon submitting the bug bounty to the Hydra smart contract, one can front-run the bug report and claim the bounty instead of the original reporter. In order to mitigate this issue they proposed \textit{Submarine Commitments} which extend commit and reveal; we discuss them further in Section~\ref{submarineCommits}.

Double-spending attacks in Bitcoin have also been studied~\cite{bamert2013have,karame2012double} where a user broadcasts a transaction and is able to obtain some off-blockchain good or service before the transaction has actually been (fully) confirmed. The user can then broadcast a competing transaction that sends the same unspent coins to herself, perhaps using higher transaction fees, arrangements with miners or artifacts of the network topology to have the second transaction confirmed instead of the first. We think of this as a type of front-running.

In the cryptographic literature, front-running attacks are modelled by allowing a `rushing' adversary to interact with the protocol. In particular, ideal functionalities of blockchains (such as those used in simulation-based proofs) need to capture this adversarial capability, assuming the real blockchain does not address front-running. See \eg~\cite{garay2015bitcoin} and Hawk~\cite{kosba2016hawk}.

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = TOP 25
% = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Cases of Front-running in DApps}  
\input{setup/table}

To find example DApps to study, we use the top 25 DApps based on recent user activity from \texttt{DAppradar.com} and sample it in the first week of September 2018\footnote{List of decentralized applications \url{https://DAppradar.com/DApps}}. User activity is admittedly an imperfect metric for finding the `most significant' DApps: significant DApps might be lower volume overall or for extended periods of time (\eg ICOs, which we remedy by studying independently in Section~\ref{sec:ICOsfrontrunning}). However, user activity is arguably the best objective criteria for which data is readily available, the list captures our intuition about which DApps are significant, and it is at least better than an ad hoc approach. Using the dataset, we categorized the top 25 applications into 4 principal use cases. The details are given in Table~\ref{tab:top25DApps}.

% = = =  

\subsection{Markets and Exchanges} \label{sec:frontrunningExchanges}

% talk about velocity ~\cite{eskandari2017feasibility} that seems to be not front-runnable but because of the liquidity pool limitation, there can be an order that consumes the last chunk of liquidity ``edge case'', to front run others and make their "option calls" fail
%Tragedy of the commons
% the smart contract is the entity that acts as the market maker on regular cases with high liquidity front-running of the option calls do not result in any advantages, however, in the case of low balance of smart contracts pool of funds, the front-runner can front-run others to use up the remaining of the funds and make the rest of the option calls fail. 

\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Miner_reorder_frontrun.png}
\caption{ The adversarial miner can monitor the Ethereum mempool for decentral exchange cancel orders and upon seeing the cancellation transaction, he puts his buy order prior to the cancel transaction. Doing so, the miner can profit from the underlying trade and also get the gas included in the cancel transaction. \label{fig:MinerFrontrunning}} 
\end{figure}
%https://www.lucidchart.com/invitations/accept/c8768786-4a3f-4c78-b3c8-aa04a6b81d06

The first category of DApp in Table~\ref{tab:top25DApps} is exchanges. Exchanges such as EtherDelta\footnote{Also known as ForkDelta for the UI \url{https://forkdelta.app/}}, purport to implement a decentralized exchange, however, their order books are stored on a central server they control and shown to their users with a website interface. Central exchanges can front-run orders in the traditional sense, as well as re-order or block orders on their servers. 0xProtocol~\cite{warren20170x} uses \textit{Relayers} which act as the order book holders and could front-run the orders they relay. One method of price manipulation on financial markets is to flood the market with orders and cancel them when there are filling orders --taker's griefing--, to prevent such attacks, the user needs to send a transaction to cancel each of his orders. The reason for canceling order could be the unprofitability of the order due to price change. In this case, when an adversarial actor sees a pending cancellation transaction, he sends a fill order transaction with higher gasPrice to get in front of the cancellation order and take the order before it is canceled, this is known as \textit{cancellation grief}. This is illustrated in Figure~\ref{fig:MinerFrontrunning}.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Regular_frontrunning.png}
\caption{The Adversary upon seeing the Buy order sends his own buy order with higher gas to front-run the first order. \label{fig:RegularFrontrunning}} 
\end{figure}
%https://www.lucidchart.com/invitations/accept/f8ca2662-5269-425d-9deb-deb14af2aac7


Designing truly decentralized exchanges, where the order book is implemented directly on a public blockchain, is being pursued by a number of projects~\cite{inDEXgithub}. These designs generally face the following attack (illustrated in Figure~\ref{fig:RegularFrontrunning}). An adversary can monitor the network with a full node for pending \textit{buy} (or \textit{sell}) transactions which could increase (or \textit{decrease}) the future price of the asset. A front-runner can send a competing order with a higher gas price and hope to have her transactions mined ahead of the original pending transaction. The benefits of doing this vary. If the original bid is a large market order (\ie it will execute at any price), the adversary can front-run a pair of limit orders that will bid near the best offer price and offer at a higher price. If these execute ahead of the market order, the front-runner profits by scalping the price of the shares. If the adversary has pre-existing offers likely to be reached by the market order, she could front-run a cancelation and a new offer at a higher price. A simpler attack would be to gauge the demand for trades at a given price by the number of pending orders and to front-run at the same price in hopes that the market demand is the result of the accurate new market information. Miners are in the best position to conduct these attacks as they hold fine-grained control over the exact set of transactions that will execute and in what order and can mix in their own (late) transactions without broadcasting them. Miners do however have to commit to what their own transactions will be before beginning the proof of work required to solve a block. 

% Front-running can also occur in non-financial smart contracts. As an example, a smart contract which adds all the participants to a party invite list could only be closed by the smart contract owner. In this case, when the owner sends the transaction to close the list, a miner can include his own list of participants before the close transaction in the block he mines. This is an issue with the design of the smart contracts and is known as transaction-ordering dependence vulnerability~\cite{luu2016making}. 

Bancor is another DApp that allows users to exchange their tokens without any counter-party risk. The protocol aims to solve the cryptocurrency liquidity issue by introducing \textit{Smart Tokens}~\cite{hertzog2017bancor}. Smart tokens are ERC20-compatible that can be bought or sold through a DApp-based dealer that is always available and implements a market scoring rule to manage its prices. Bancor provides continuous liquidity for digital assets without relying on brokers to match buyers with sellers. Implemented on the Ethereum blockchain, when transactions are broadcast to the network, they sit in a pending transaction pool known as \textit{mempool} waiting for the miners to mine them. Since Bancor handles all the trades and exchanges on the chain (unlike other existing decentralized exchanges), these transactions are all visible to the public for some time before being included within a block. This leaves Bancor vulnerable to the blockchain race condition attack as attackers are given enough time to front-run other transactions, in which they can gain favourable profits by buying before the order and fill the original order with slightly higher price~\cite{BancorIs7:online}. Researchers have shown and implemented a proof of concept code to front-run Bancor as a non-miner user~\cite{NewTab13:online}.

% = = = 

\subsection{Crypto-Collectibles Games}\label{sec:cryptogames}

The second category of DApp in Table~\ref{tab:top25DApps} is crypto-collectables. Consider Cryptokitties\footnote{Cryptokitties website \url{https://www.cryptokitties.co/}}, the most active DApp in this category and third most active overall. Each kitty (see Appendix~\ref{app:cryptokitty}) is a cartoon kitten with a set of unique features to distinguish it from other cryptokitties, some features are rarer and harder to obtain. They can be bought, sold, or bred with other cryptokitties. At the Ethereum level, the kitty is a token implemented with \textit{ERC-721: Non-Fungible Token Standard}~\cite{erc721}. The market cap of cryptokitties peaked at more than 6 million dollars in the first few months of their launch, however, it has declined since. ERC-721 are similar enough to ERC-20 tokens that they can be listed on exchanges that are ERC-20 compatible. To buy a kitty, the user sends the following bid transaction: \texttt{bid(uint256 \_tokenId)}. It contains the kitty's ID which can be found either on their website or on the ERC721 token smart contract. This is similar to open auctions and markets on section~\ref{sec:frontrunningExchanges}, bid value and the object bidding on is visible to the network and any user could  easily front-run by sending the same transaction with higher gasPrice to replace the initial bidder. The front-runner can see there is an interest in a specific kitty and by buying it and auctioning it at a higher price can profit from the transaction. %we call this auction-frontrunning. 
% https://etherscan.io/tx/0x62a76b7e345e8abd463487d0348c118a9314b197024e090fee7b1fbce434da40

% = = = 

\subsection{Gambling.} 

The third category of DApp in Table~\ref{tab:top25DApps} is gambling services. While a large category of gambling games are based on random outcomes, DApps do not have unique access to an unpredictable data stream to harvest for randomness. Any candidate (such as block headers) source of randomness is accessible to all DApp functions and can also be manipulated to an extent by miners.

\textsf{Fomo3D} is an example of a game style (known as \textsf{Exit Scam}\footnote{\url{https://exitscam.me/play}}) not based on random outcomes, and it is the most active game on Ethereum in our sample. The aim of this game is to be the last person to have purchased a ticket when a timer goes to zero in a scenario where anyone can buy a ticket and each purchase increases the timer by 30 seconds. Many speculated such a game would never end but on August 22, 2018, the first round of the game ended with the winner collecting 10,469 Ether\footnote{The first winner of Fomo3D, won 10,469 Ether \url{ https://etherscan.io/tx/0xe08a519c03cb0aed0e04b33104112d65fa1d3a48cd3aeab65f047b2abce9d508}} equivalent to \$2.1M USD at the time. 
Blockchain forensics indicate a sophisticated winning strategy to front-run new ticket purchases~\cite{fomo3dhacker} that would reset the counter. The winner appears to have started by deploying some high gas consumption DApps unrelated to the game. When the timer of the game reached about 3 minutes, the winner bought 1 ticket and then sent multiple high gasPrice transactions to her own DApps. These transactions congested the network and bribed miners to prioritize them ahead of any new ticket purchases in \textsf{Fomo3D}. 

% Is this the same as order flooding in HFT?

% = = = 

\subsection{Name Services.}\label{sec:ens}

The final category in Table~\ref{tab:top25DApps} is name services, which are primarily aimed at displacing central parties involved in web domain registration (\eg ICAAN and registrars) and resolution (\eg DNS). For simple name services (such as some academic work like Ghazal~\cite{moosavighazal}), domains purchases are transactions and network monitors can front-run other users attempting to register domains. This parallels front-running attacks seen in regular (non-blockchain) domain registration~\cite{sac022en33:online}. \textsf{Ethereum Name Service (ENS)}\footnote{\url{https://ens.domains/}} is the most active naming service on Ethereum. Instead of allowing new \texttt{.eth} domain names to be purchased directly, they are put up for a sealed bid auction which seals the domain name in the bids, but not the bid amounts. The most common way of getting a domain is to call \texttt{startAuctionsAndBid()} in ENS auction smart contract, which leaks the hash of the domain name and the initial bid amount in the auction. Users are allowed to bid for 48 hours before the 48-hour reveal phase begins, in which bidders must send a transaction to reveal their bids for a specific domain in the auction. It is possible for a user to front-run other bids with the same bid amount by revealing first. The auction model is similar to crypto-collectibles auctions in \ref{sec:cryptogames}.

%% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = ICOs
% = = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Cases of Front-running in ICOs}  \label{sec:ICOsfrontrunning}

Initial coin offerings (ICOs) have changed how blockchain firms raise capital. More than 3000 ICOs have been held on Ethereum, and the market capitalization of these tokens appear to exceed \$75B USD in the first half of 2018~\cite{zetzsche2018ico}. At the DApp level, tokens are offered in short-term sales that see high transaction activity while the sale is on-going and then ICO activity tapers off to occasional owner transfers. When we collected the top 25 most active DApps on \texttt{DAppRadar.com}, no significant ICOs were in the initial sale stage. Despite the ICO category falls through our sampling method, we identify it as a major category of DApp and study it here. 

\subsection{\textit{Status.im} ICO}
To deal with demand, ICOs cap sales in a variety of ways to mitigate front-running attacks. In June 2017, \textit{Status.im}~\cite{statuswhitepaper} started its ICO and reached the predefined cap within 3 hours, collecting close to 300,000 Ether. In order to prevent wealthy investors purchasing all the tokens and limit the amount of Ether deposited in each investment, they used a \textit{fair} token distribution method called \textit{Dynamic Ceiling} as an attempt to increase the opportunity for smaller investors. They implemented multiple caps (ceilings) in which, each had a maximum amount that could be deposited in. In this case, every deposit was checked by the smart contract and the exceeding amount was refunded to the sender while the accepted amount was sent to their multi-signature wallet address~\cite{statusicoanalysis}. 

During the time the ICO was open for participation, there were reports of Ethereum network being unusable and transactions were not confirming. Further study showed that some mining pools might have been manipulating the network for their own profit. In addition, there were many transactions sent with a higher gas price to front-run other transactions, however, these transactions were failing due to the restriction in the ICO smart contract to reject any transactions with higher than 50 \textit{GWei} gas price (another mitigation against front-running).

\begin{figure}[t]
\centering
\includegraphics[width=0.5\linewidth]{figures/Mining_pool_ratio.png}
\caption{ The percentage of Ethereum blocks mined between block 3903900 and 3908029, this is the time frame in which Status.im ICO was running. This percentage roughly shows the hashing power ratio each miner had at that time. \label{fig:mining_pool_ratio}} % IS THIS STATEMENT CORRECT?
\end{figure}

\subsection{Data Collection and Analysis}
According to analysis we carried out, we discovered that the F2Pool---an Ethereum mining pool that had around 23\% of the mining hash rate at the time (Figure~\ref{fig:mining_pool_ratio})---sent 100 Ether to 30 new Ethereum addresses before the Status.im ICO started. When the ICO opened, F2Pool constructed 31 transactions to the ICO smart contract from these new address, without broadcasting the transactions to the network. They used their entire mining power to mine their own transactions and some other potentially failing high gas price transactions.

Ethereum's blockchain contains all transaction ever made on Ethereum. While the default client and online blockchain explorers offer some limited query capabilities, in order to analyze this case, we built our own database. Specifically, we used open source projects such as Go Ethereum implementation\footnote{Official Go implementation\url{https://github.com/ethereum/go-ethereum}} for the full node, a python script for extracting, transforming and loading Ethereum blocks, named \texttt{ethereum-etl}~\cite{ethereumetl} and Google BigQuery.\footnote{\url{https://cloud.google.com/bigquery/}} Using this software stack, we were able to isolate transactions within the Status.im ICO. We used data analysis tool \texttt{Tableau}.\footnote{\url{https://www.tableau.com/}} A copy of this dataset and the initial findings can be found in our Github repository.\footnote{\url{github.com/} Removed for anonymity.}

As shown in Figure~\ref{fig:Transactions_miners_while_status_ico_cut}, most of the top miners in the mentioned time frame, have mined almost the same number of failed and successful transactions which were directed toward Status.im token sale, however F2Pool's transactions indicate their successful transactions were equivalent to 10\% of the failed transactions, hence maximizing the mining rewards on gas, while censoring other transactions to the token sale smart contract. The terminology used here is specific to smart contract transactions on Ethereum, by \textit{``failed transaction''} we mean the transactions in which the smart contract code flow rejected and threw an exception and by \textit{``successful transaction''} we mean the transactions that went through and received tokens from the smart contract. 


\begin{figure}[t]
\centering
\includegraphics[width=0.9\linewidth]{figures/Transactions_miners_while_status_ico_cut_only_icotx.png}
\caption{ This chart shows the miners behaviour on the time window that Status.im ICO was running. It is clear that the number of successful transactions mined by F2Pool do not follow the random homogeneous pattern of the rest of the network. \label{fig:Transactions_miners_while_status_ico_cut}} 
\end{figure}

% make pie charts for each mining pool, all non-status-ico transactions vs success-ico-transactions vs failed-ico=transactions

\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/F2Pool_transactions_to_StatusICO_and_Refunds.png}
\caption{ F2Pool prior to Status.im ICO deposited 100 Ether in multiple new Ethereum addresses. On the time of the ICO they sent these deposits to Status ICO smart contract and prioritized mining of these transactions in their mining pool, this was to overcome the dynamic ceiling algorithm of the token sale smart contract. Later on they sent the refunded Ether back to their own address. [Graph made using Blockseer.com] \label{fig:f2poolfront-run}}
\end{figure}

By tracing the transactions from these 30 addresses, we found explicit interference by the F2Pool\footnote{F2Pool Ethereum address was identified by their mining reward deposit address \url{https://etherscan.io/address/0x61c808d82a3ac53231750dadc13c777b59310bd9}} in this scenario. As shown in Figure~\ref{fig:f2poolfront-run}, the funds deposited by F2Pool in these addresses were sent to Status.im ICO and mined by F2Pool themselves, where the dynamic ceiling algorithm refunded a portion of the deposited funds back to these addresses, these funds were sent back to F2Pool main address a few days after and the tokens were aggregated later on in one single address. Although this incident does not involve transaction reordering in the blocks, it shows how miners can modify their mining software to behave in a certain way to front-run other transactions and gain monetary profit.


% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Mitigations
% = = = = = = = = = = = = = = = = = = = = = = = = = = %


\section{How to stop Front-running?} %We have the applicability of the solutions inline.

There are two main approaches to mitigating front-running on blockchains: one is to design a blockchain that is front-run resistant, and the other to design the application logic in a way that front-running is not profitable. This can be done in addition to any legal remedies that might be enforceable (See Appendix ~\ref{app:traditionalprevention}). We note, but consider out-of-scope, approaches that introduce trusted parties to centralize time-sensitive functionalities (\eg exchanges \textit{EtherDelta} and \textit{0xProject} use off-chain order books~\cite{warren20170x,0xfrontrunning:online}). 


% = = =

\subsection{Front-Running Resistant Blockchains}
In this section, we describe the potential solutions using which, one can design and implement a decentralized application that is resistant to front-running. Note that, the existing technical difficulties make these solutions hard to achieve as it requires designers to test edge case scenarios. 

\paragraph{Design Decision \#1: Fixed Transaction Ordering.} da Silva~\etal~\cite{fixedordering2018silva} proposes an algorithm, known as Fixed Transaction Ordering and Admission (FTOA), in the consensus protocol that enforces the order of the transactions in the mined blocks, using logical timestamps in a Byzantine setting, to eliminate transaction reordering by miners. This is a theoretical solution and is not trivial to implement in the current Byzantine consensus protocols.

\paragraph{Design Decision \#2:Privacy-Preserving Blockchains.}
Privacy-preserving blockchains strive (to some extent~\cite{miller2017empirical,kappos2018empirical}) to keep all details of transactions private, including participants and amounts. As an example, ZCash~\cite{hopwood2016zcash} uses two distinct types of addresses, transparent and shielded addresses. Transparent addresses work similar to Bitcoin transactions, fully transparent about the sender and receiver addresses, the amount and included data. However, shielded addresses are private and do not leak any information. While this solution works for simple transactions, building similar shields for DApps is subject to on-going research~\cite{kosba2016hawk}. With the possibility of having private smart contracts in such a setting, it could be feasible to achieve a front-run resistance blockchain, however, the functionality of the smart contracts could be limited. 


\begin{figure}[t]
\centering
\includegraphics[width=0.9\linewidth]{figures/Vulnerable_Loopring.png}
\caption{ \emph{submitRing} Transaction in the old version of the Loopring protocol. Any user can regenerate this transaction by replacing the miner's address with his address and signing the hash of the ring using his private key. \label{fig:vulnerable_loopring}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/33d38ce9-4660-4743-806d-45c72f7e8393
\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Dual_Authoring_Loopring.png}
\caption{ \emph{submitRing} Transaction in the new version of the Loopring protocol. Other users cannot regenerate this transaction as they do not access auth-keys and hence are not able to create the signatures. \label{fig:not_vulnerable_loopring}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/8dee869c-482c-433f-a901-8d041a1dc526

%The first solution was to prevent front-running, but then it was attacked so they updated the solution. this new solution also could be attacked. 
\paragraph{Design Decision \#3: Dual Authoring.} This scheme is proposed to solve the front-running issue within Loopring -- a decentralized exchange protocol proposed by Wang~\etal~\cite{wang2018loopring}. In the first version of this protocol, orders are grouped in \emph{ring orders} once they are sent by the users. After the required signatures are provided by the \textit{ring miner}, he sends the \emph{submitRing transaction} to the Loopring Smart Contract (LPSC) for verification and settlement (see Figure~\ref{fig:vulnerable_loopring}). While this transaction sits unconfirmed in the mempool, any front-runner can create a copy of this transaction with higher gasPrice and his address instead of the ring miner's address. Using the proposed \textit{dual authoring} solution in the new version of Loopring, regeneration of the \emph{submitRing transaction} is infeasible as the users have to sign the orders using their secondary private keys (auth-keys), which are only known to the ring miner and not other users (see Figure~\ref{fig:not_vulnerable_loopring}).


% Loopring protocol is proposed by Wang~\etal to build decentralized exchanges~\cite{wang2018loopring}. In this protocol, the orders are grouped in \emph{ring orders} immediately after they are sent by the users. Next, the required signatures are provided by a miner and owner of the order, see Figure~\ref{fig:vulnerable_loopring}. Eventually, the ring miner sends the \emph{submitRing transaction} to the Loopring Smart Contract (LPSC) for verification and settlement. While the \emph{submitRing transaction} sits unconfirmed in the mempool, any front-runner can create a copy of this transaction with his address instead of the ring miner's address and then sign the hash of the ring using his own private key. By paying a higher gasPrice, block miners choose the front-runner's transaction instead of the original \emph{submitRing transaction}. 
%To solve this issue, the new version of Loopring protocol uses the \emph{dual-authoring} scheme. This solution sets two levels of authorization for orders - one for settlement, and one for order matching. As it can be seen in Figure~\ref{fig:not_vulnerable_loopring}, each owner of an order generates a pair of public key (auth-address) and private key (auth-key), which are different from his address and its corresponding private key. These auth-keys are used to sign the hash of the ring and will further prevent anyone from regenerating the same \emph{submitRing transaction}. The reason is that the auth-keys are only known to the miner of the ring as they are not part of the on-chain transaction. Doing so, it is assured that (i) the orders are not modified because they are signed by the owner, (ii) no other miner can mine the ring because the miner's address is signed by the initial miner, and (iii) no user can front-run the \emph{submitRing transaction} because other users do not have access to the auth-keys and hence are not able to generate new transactions with auth-keys signatures on them.

% = = =

\subsection{Application Design to Prevent Front-running}

Front-running can be tackled at the blockchain layer, as seen in the previous section, or mitigations can be built at the DApp level as seen here. 

\paragraph{Design Decision \#1: Commit / Reveal.} \label{CommitmentScheme}
A commitment scheme is a cryptographic primitive that enables one to commit to a value (\eg a statement, document, data, \etc) while keeping it a secret, and then open it (and only it) at a later time of the committer's choosing~\cite{brassard1988minimum}. A common approach is to submit the hash value of the data to be committed, potentially with a random nonce (for predictable data), to a smart contract and later reveal the original data and nonce which can be verified to hash to the commitment. See Figure~\ref{fig:commitReveal} in Appendix~\ref{app:cr}. 

An early use of this scheme is Namecoin, a Bitcoin-forked blockchain for name services~\cite{kalodner2015empirical}. In Namecoin, a user sends a commit transaction which commits to the name hash, similar to a sealed bid. Once the transaction is confirmed and the grace period is over, the user sends a reveal transaction revealing the bid and also the details of the requested domain~\cite{kalodner2015empirical}. Hence, the user is able to hide information from the adversarial parties in the system and prevent front-running attacks. 

In the case of decentralized exchanges, users can use commit/reveal for bids, where commitments are placed in an ordered queue and executed in a later round after a reveal. This mitigation seems to require further research. One trader strategy is to flood orders at the commitment stage, but then only selectively and adaptively choose which to reveal. Collateralization is another challenge, where revealed bids may simply be intentions to execute but additional transactions are required to move the money or tokens; a transaction that can also be aborted early. One mitigation to early aborts is having users post a fidelity bond that can be automatically dispensed if they fail to fully execute committed transactions (as used in~\cite{mccorry2017smart}). Commit/reveal is also seen in on-chain voting~\cite{adChainPLCRVoting}. Using sealed votes, voters can assure their votes are hidden until a later date, however, their participation and weight of the vote are publicly known. 

The participatory factor is another issue for the commitment scheme. For anyone watching the DApp address, there will be a direct transaction from the user to the DApp address, revealing the fact that a specific address has participated in the auction or the DApp using a commit and reveal scheme, but the details are hidden through the scheme. Both these issues, albeit hiding the details of the order and preventing direct front-running, leak information to other participants which could lead to more sophisticated front-running attacks depending on the application design. On the other note, these method has some drawbacks, the user experience is not smooth and one might forget to reveal the committed transaction. In the ENS commit-reveal process, if one forgets to reveal in the reveal phase, the committed funds are burnt and inaccessible thereafter. Also, this scheme means two transactions are required for a functionality which makes it more expensive.

\begin{figure}[t]
\centering
\includegraphics[width=0.5\linewidth]{figures/LibSubmarine.png}
\caption{ Submarine Send~\cite{libsubmarine}. User generates an \textit{Unlock} transaction from which the commitment address is retrieved. By funding the \textit{commitment address}, user is committed to the unlock transaction. After the commitment transaction, in the reveal phase, user sends the \textit{reveal transaction} to the DApp and then after she can broadcast the Unlock transaction to unlock the funds in the commitment address. Finally after the "Auction'' is over, anyone can call \textit{Finalize} function to finalize the process.  \label{fig:LibSubmarine}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/3a259b74-1162-4fb5-8023-eb0311018295

\paragraph{Design Decision \#2: Submarine Commitments.}\label{submarineCommits}
Submarine Commitments~\cite{breidenbach2018enter,submarinesendHD} extend basic commit/reveal functionality with additional properties. In particular, they hide the DApp being invoked during the commit phase and also ensure that revealed transactions that send funds are fully collateralized. With submarine send, it is possible to hide sender, receiver, value, and data, so the commitment transaction is identical to a transaction to a newly generated address. Submarine sends could be a solution for sealed-bid auctions on the blockchain to hide the existence of the bids for other participants. The details of how Submarine commitments work could fill an entire paper, however in short, using the way Ethereum transactions are constructed and ECDSA ECRecover functionality, it is possible to generate one outgoing transaction from an address of which no private key exists. By constructing a transaction from that address to the DApp and funding that address we fulfill the commitment phase. By revealing the details and broadcasting the constructed transaction we reveal the commitment~\cite{libsubmarine}. See Figure~\ref{fig:LibSubmarine}. However, this could be designed in other ways to suit the need of the DApp. Drawbacks of this scheme are similar to commit/reveal, with the addition of two more transactions to finalize a transaction, which adds cost and complexity to the user experience.

\paragraph{Design Decision \#3: Use-Case Specific Solutions.}
There is no perfect generic solution to this issue as of now, however, to prevent front-running, one can design the application in a way that it is not possible to be front-run:

\begin{compactlist}

\item \emph{Eliminating Time-Order Dependency:} The applications can be designed not to rely on the time for the orders to be executed. For example when designing a decentralized exchange, one can use a \emph{the call market} design instead of a time-sensitive order book~\cite{clark2014decentralizing} to side-step and disincentivize front-running by miners. In a call market design, the arrival time of orders does not matter as they are executed in batches. 

\item \emph{Disincentivizing Front-running Actors:} The call market solution also pivots profitable gains that front-running miners stand to gain into fees that they collect~\cite{clark2014decentralizing}, removing the financial incentive to front-run. To the same end, Malinova~\cite{malinova2017market} proposes a design for a decentralized exchange which uses economic models in their trading market design to make front-running expensive and more costly than profitable. They split big investments into smaller ones using intermediaries --liquidity demander-- and liquidity providers to achieve this.

\item \emph{Trusted party:} It is possible to use a central trusted party, to mitigate the risks of front-running on the DApp design. As an example, LocalEthereum, an escrow-based exchange, facilitates the website as the matchmaking service for the exchange orders, and uses challenge random values from the website to be included in the signature of the transaction (See Code ~\ref{code:localethereum} in Appendix~\ref{app:localethereum}), hence removing any possibility of replay attack or the possibility of any other address modifying key information in the order. This method prevents network observers to be able to make a new transaction with the defined values as the third party will be the final entity approving the transaction.
 \end{compactlist}

% one solution could be to remove multiple actors, meaning that on each "play" (order), the smart contract would be the market maker. it does not matter if there are multiple similar orders. similar to PoC of Velocity~\cite{eskandari2017feasibility}. Although there are other concerns about this specific design but not for front-running.

%TODO: inline talk about what these solutions are good for and if they fit Status ICO

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Conc
% = = = = = = = = = = = = = = = = = = = = = = = = = = % 

\section{Concluding Remarks}

Front-running is a pervasive issue in Ethereum DApps. While some DApp-level application logic could be built to mitigate these attacks, its ubiquity across different DApp categories suggests mitigations at the blockchain-level would perhaps be more effective. We highlight this as an important research area. 

% Could talk about future work on a tool / a framework to detect front-running


