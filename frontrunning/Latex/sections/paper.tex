% !TEX root = ../main.tex

\section{Introduction} \label{sec:intro}

Blockchain technology enables decentralized applications (DApps) or smart contracts. Function calls (or transactions) to the DApp are processed by a decentralized network. Transactions are finalized in stages: they (generally) first relay around the network, then are selected by a miner and put into a valid block, and finally, the block is well-enough incorporated that is unlikely to be reorganized. Front-running is an attack where a malicious node observes a transaction after it is broadcast but before it is finalized, and attempts to have its own transaction confirmed before or instead of the observed transaction.

The mechanics of front-running works on all DApps but front-running is not necessarily beneficial, depending on the DApp's internal logic and/or as any mitigations it might implement. Therefore, DApps need to be studied individually or in categories. In this paper we draw from a scattered body of knowledge regarding front-running attacks on blockchain applications and proposed solutions, with series of case studies of DApps deployed on Ethereum (a popular blockchain supporting DApps) from each category of the top 25 most active, based on user activity.\footnote{List of decentralized applications \url{https://DAppradar.com/DApps}} We do case studies on decentralized exchanges (\eg Bancor), crypto-collectibles (\eg CryptoKitties), gambling services (\eg Fomo3D), and decentralized name services (\eg Ethereum Name Service). We also study initial coin offerings (ICOs), which by happenstance, did not appear in the top 25 on our sample day. After a few hacking incidents of high valued smart contracts~\cite{siegel2016daohack}, ICOs started to implement restrictions and capped how much funds can be gathered. This scarcity of the initial coins made for a competition to incentivize big investors to get in and buy the tokens at a discounted price and sell them to latecomers on the open markets~\cite{zetzsche2018ico,li2018initial}. ICOs started to experiment with different \textit{fair} capping methods, such as reverse dutch auction and dynamic ceilings~\cite{kaal2017initial}. We show empirical evidence of a miner purchasing tokens ahead of other users in Status.im. Finally, proposals to eliminate or mitigate front-running from DApps are scattered across forums, proposed standards (called EIPs in Ethereum) and academic papers; we systemize them in the last section.

% Developers don't have the mindset to design DApps with front-running in mind. This is an attempt to bring forward the subject and make them more aware of these type of attacks

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Preliminaries
% = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Preliminaries \& Related Work}

\subsection{Traditional Front-running}
\label{sec:What is front-running?}

\emph{Front-running} is a course of action where someone benefits from early access to market information about upcoming transactions and trades, typically because of a privileged position along the transmission of this information and is applicable to both financial and non-financial systems. In traditional stock exchanges, floor traders might overhear a broker's negotiation with her client over a large purchase, and literally race the broker to buy first, potentially profiting when the large sale temporarily reduces the supply of the stock. A malicious broker might also front-run their own client's orders by purchasing stock for themselves between receiving the instruction to purchase from the client and actually executing the purchase (similar techniques can be used for large sell orders). Front-running is unethical and illegal in jurisdictions with mature securities regulation.

Cases of front-running are sometimes difficult to distinguish from related concepts like insider trading and arbitrage. In front-running, a person sees a concrete transaction that is set to execute and reacts to it before it actually gets executed. If the person instead has access to more general privileged information that might predict future transactions, but is not reacting at the actual pending trades, we would classify this activity as insider trading. If the person reacts after the trade is executed, or information is made public, and profits from being the fastest to react, this is considered arbitrage and is legal and encouraged because it helps markets integrate new information into prices quickly.


%maybe move this to appendix
\subsection{Literature on Traditional Front-running}\label{traditionalFrontrunning}
Front-running originates on the Chicago Board Options Exchange (\textit{CBoE}) \cite{markham1988front}. The Securities Exchange Commission \textit{(SEC)} in 1977 defines it as: ``The practice of effecting an options transaction based upon non-public information regarding an impending block transaction\footnote{A block in the stock market is a large number of shares, 10\,000 or more, to sell which will heavily changes the price} in the underlying stock, in order to obtain a profit when the options market adjusts to the price at which the block trades.~\cite{sec1978optionsmarket}'' Self-regulating exchanges (\eg \textit{CBoE}) and the \textit{SEC} spent the ensuing years planning how to detect and outlaw front-running practices~\cite{markham1988front}. The \textit{SEC} stated: ``It seems evident that such behaviour on the part of persons with knowledge of imminent transactions which will likely affect the price of the derivative security constitutes an unfair use of such knowledge.\footnote{Securities Exchange Act Release No. 14156, November 19, 1977, (Letter from George A. Fitzsimmons, Secretary, Securities, and Exchange Commission to Joseph W. Sullivan, President  CBoE).}'' The \textit{CBoE} tried to educate their members on existing rules, however, differences in opinion regarding the unfairness of front-running activities, insufficient exchange rules and lack of a precise definition in this area resulted in no action~\cite{sec1978optionsmarket} until the SEC began regulation. We refer the reader interested in further details on this early regulatory history to Markham~\cite{markham1988front}. The first front-running policies applied only to certain option markets. In 2002, the rule was expanded to cover all security futures~\cite{finra_2002}. In 2012, it was expanded further with the new amendment, FINRA Rule 5270, to cover trading in options, derivatives, or other financial instruments overlying a security with only a few exceptions~\cite{sec2012frontrunning,finra_2012}.

% we can say other illegal activities in the tranditional system, such as wash trading, ... (notes from AMF) could fall under our definition of front running on blockchain apps, as the transparency and public nature of the transactions could result in any actor to be involved in such trades? does it make sense?


\subsection{Background on Blockchain Front-running} \label{sec:Front Running on the Blockchains}

In one sense, blockchain technology (which was introduced via Bitcoin in 2008~\cite{nakamoto2008bitcoin}) strives to disintermediate certain central parties that participate in a transaction. However, blockchains also introduce new participants in the relaying and finalization (\ie mining) of transactions that can act as front-runners. Any user monitoring blockchain network transactions (\eg running a full node) can see an unconfirmed transactions and broadcast a reactionary transaction that might be confirmed ahead of the original transaction. For regular users to front-run others on the blockchain, they need to be well connected to other nodes on the network and listen to the network to monitor all transactions that are broadcast. On the Ethereum blockchain, users have to pay for the computations in a small amount of Ether called \textsf{gas}~\cite{AccountT67:online}. The price that users pay for transactions, \textsf{gasPrice}, can increase or decrease how quickly miners will execute them and include them within the blocks they mine. Once seeing two identical transactions with different transaction fees, a rational miner will prioritize the transaction that pays a higher gas price, due to limited space in the blocks. Therefore, any regular user who runs a full-node Ethereum client can front-run pending transactions by sending similar transaction with a higher gas price. Also, blockchain miners are the only parties who can decide on the order of transactions within a block they mine, they can easily intercept and reorder the transactions in their blocks, this in case of malicious reordering is known as \textsf{transaction reordering} attack.

\subsection{Literature on Blockchain Front-running}

Given the purpose of this entire paper is systemizing the existing literature, we do not re-enumerate the literature here. However, we note two things. First, we are not aware of any other systematic study of this issue. Second, front-running is related to two concepts that are often not considered front-running per se: double-spending and rushing adversaries. 

% Jeremy: redistribute this to the relevant section
%Aune~\etal discuss how the lack of time priority between broadcasting a transaction and its validation by miners on a blockchain based system would lead to market information leakage~\cite{aune2017footprints}. They also propose a cryptographic approach, similar to commit and reveal (see Section~\ref{sec:comm}) to prevent front-running. 


% Jeremy: this is well described already, but we should use the bug-bounty example (citing this) somewhere in the paper as it is a nice example
%Breidenbach~\etal~\cite{breidenbach2018enter} face the front-running issue in the context of automating bug bounties for smart contracts. Upon submitting the bug bounty to the Hydra smart contract, one can front-run the bug report and claim the bounty instead of the original reporter. In order to mitigate this issue they proposed \textit{Submarine Commitments} which extend commit and reveal; we discuss them further in Section~\ref{sec:comm}.

% Jeremy: The following two paragraphs are fine 

Double-spending attacks in Bitcoin are related to front-running~\cite{bamert2013have,karame2012double}. In this attack, a user broadcasts a transaction and is able to obtain some off-blockchain good or service before the transaction has actually been (fully) confirmed. The user can then broadcast a competing transaction that sends the same unspent coins to herself, perhaps using higher transaction fees, arrangements with miners or artifacts of the network topology to have the second transaction confirmed instead of the first. This can be considered a form of self-front-running.

In the cryptographic literature, front-running attacks are modelled by allowing a `rushing' adversary to interact with the protocol. In particular, ideal functionalities of blockchains (such as those used in simulation-based proofs) need to capture this adversarial capability, assuming the real blockchain does not address front-running. See \eg Bitcoin backbone~\cite{garay2015bitcoin} and Hawk~\cite{kosba2016hawk}.

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = TOP 25
% = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Cases of Front-running in DApps}
\input{setup/table}

To find example DApps to study, we use the top 25 DApps based on recent user activity from \texttt{DAppradar.com} and sample it in the first week of September 2018\footnote{List of decentralized applications \url{https://DAppradar.com/DApps}}. User activity is admittedly an imperfect metric for finding the `most significant' DApps: significant DApps might be lower volume overall or for extended periods of time (\eg ICOs, which we remedy by studying independently in Section~\ref{sec:ICOsfrontrunning}). However, user activity is arguably the best objective criteria for which data is readily available, the list captures our intuition about which DApps are significant, and it is at least better than an ad hoc approach. Using the dataset, we categorized the top 25 applications into 4 principal use cases. The details are given in Table~\ref{tab:top25DApps}.

% = = =

\subsection{Markets and Exchanges} \label{sec:frontrunningExchanges}

% talk about velocity ~\cite{eskandari2017feasibility} that seems to be not front-runnable but because of the liquidity pool limitation, there can be an order that consumes the last chunk of liquidity ``edge case'', to front run others and make their "option calls" fail
%Tragedy of the commons
% the smart contract is the entity that acts as the market maker on regular cases with high liquidity front-running of the option calls do not result in any advantages, however, in the case of low balance of smart contracts pool of funds, the front-runner can front-run others to use up the remaining of the funds and make the rest of the option calls fail.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Miner_reorder_frontrun.png}
\caption{ The adversarial miner can monitor the Ethereum mempool for decentral exchange cancel orders and upon seeing the cancellation transaction, he puts his buy order prior to the cancel transaction. Doing so, the miner can profit from the underlying trade and also get the gas included in the cancel transaction. \label{fig:MinerFrontrunning}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/c8768786-4a3f-4c78-b3c8-aa04a6b81d06

The first category of DApp in Table~\ref{tab:top25DApps} is exchanges. Exchanges such as EtherDelta\footnote{Also known as ForkDelta for the UI \url{https://forkdelta.app/}}, purport to implement a decentralized exchange, however, their order books are stored on a central server they control and shown to their users with a website interface. Central exchanges can front-run orders in the traditional sense, as well as re-order or block orders on their servers. 0xProtocol~\cite{warren20170x} uses \textit{Relayers} which act as the order book holders and could front-run the orders they relay. One method of price manipulation on financial markets is to flood the market with orders and cancel them when there are filling orders --taker's griefing--~\cite{consesnsys0xReview2017}, to prevent such attacks, the user needs to send a transaction to cancel each of his orders. The reason for canceling order could be the unprofitability of the order due to price change. In this case, when an adversarial actor sees a pending cancellation transaction, he sends a fill order transaction with higher gasPrice to get in front of the cancellation order and take the order before it is canceled, this is known as \textit{cancellation grief}. This is illustrated in Figure~\ref{fig:MinerFrontrunning}.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Regular_frontrunning.png}
\caption{The Adversary upon seeing the Buy order sends his own buy order with higher gas to front-run the first order. \label{fig:RegularFrontrunning}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/f8ca2662-5269-425d-9deb-deb14af2aac7


Designing truly decentralized exchanges, where the order book is implemented directly on a public blockchain, is being pursued by a number of projects~\cite{inDEXgithub}. These designs generally face the following attack (illustrated in Figure~\ref{fig:RegularFrontrunning}). An adversary can monitor the network with a full node for pending \textit{buy} (or \textit{sell}) transactions which could increase (or \textit{decrease}) the future price of the asset. A front-runner can send a competing order with a higher gas price and hope to have her transactions mined ahead of the original pending transaction. The benefits of doing this vary. If the original bid is a large market order (\ie it will execute at any price), the adversary can front-run a pair of limit orders that will bid near the best offer price and offer at a higher price. If these execute ahead of the market order, the front-runner profits by scalping the price of the shares. If the adversary has pre-existing offers likely to be reached by the market order, she could front-run a cancelation and a new offer at a higher price. A simpler attack would be to gauge the demand for trades at a given price by the number of pending orders and to front-run at the same price in hopes that the market demand is the result of the accurate new market information. Miners are in the best position to conduct these attacks as they hold fine-grained control over the exact set of transactions that will execute and in what order and can mix in their own (late) transactions without broadcasting them. Miners do however have to commit to what their own transactions will be before beginning the proof of work required to solve a block.

% Front-running can also occur in non-financial smart contracts. As an example, a smart contract which adds all the participants to a party invite list could only be closed by the smart contract owner. In this case, when the owner sends the transaction to close the list, a miner can include his own list of participants before the close transaction in the block he mines. This is an issue with the design of the smart contracts and is known as transaction-ordering dependence vulnerability~\cite{luu2016making}.

Bancor is another DApp that allows users to exchange their tokens without any counter-party risk. The protocol aims to solve the cryptocurrency liquidity issue by introducing \textit{Smart Tokens}~\cite{hertzog2017bancor}. Smart tokens are ERC20-compatible that can be bought or sold through a DApp-based dealer that is always available and implements a market scoring rule to manage its prices. Bancor provides continuous liquidity for digital assets without relying on brokers to match buyers with sellers. Implemented on the Ethereum blockchain, when transactions are broadcast to the network, they sit in a pending transaction pool known as \textit{mempool} waiting for the miners to mine them. Since Bancor handles all the trades and exchanges on the chain (unlike other existing decentralized exchanges), these transactions are all visible to the public for some time before being included within a block. This leaves Bancor vulnerable to the blockchain race condition attack as attackers are given enough time to front-run other transactions, in which they can gain favourable profits by buying before the order and fill the original order with slightly higher price~\cite{BancorIs7:online}. Researchers have shown and implemented a proof of concept code to front-run Bancor as a non-miner user~\cite{NewTab13:online}.

% = = =

\subsection{Crypto-Collectibles Games}\label{sec:cryptogames}

The second category of DApp in Table~\ref{tab:top25DApps} is crypto-collectables. Consider Cryptokitties\footnote{Cryptokitties website \url{https://www.cryptokitties.co/}}, the most active DApp in this category and third most active overall. Each kitty (see Appendix~\ref{app:cryptokitty}) is a cartoon kitten with a set of unique features to distinguish it from other cryptokitties, some features are rarer and harder to obtain. They can be bought, sold, or bred with other cryptokitties. At the Ethereum level, the kitty is a token implemented with \textit{ERC-721: Non-Fungible Token Standard}~\cite{erc721}. The market cap of cryptokitties peaked at more than 6 million dollars in the first few months of their launch, however, it has declined since. ERC-721 are similar enough to ERC-20 tokens that they can be listed on exchanges that are ERC-20 compatible. To buy a kitty, the user sends the following bid transaction: \texttt{bid(uint256 \_tokenId)}. It contains the kitty's ID which can be found either on their website or on the ERC721 token smart contract. This is similar to open auctions and markets on section~\ref{sec:frontrunningExchanges}, bid value and the object bidding on is visible to the network and any user could  easily front-run by sending the same transaction with higher gasPrice to replace the initial bidder. The front-runner can see there is an interest in a specific kitty and by buying it and auctioning it at a higher price can profit from the transaction. %we call this auction-frontrunning.
% https://etherscan.io/tx/0x62a76b7e345e8abd463487d0348c118a9314b197024e090fee7b1fbce434da40

% = = =

\subsection{Gambling.}

The third category of DApp in Table~\ref{tab:top25DApps} is gambling services. While a large category of gambling games are based on random outcomes, DApps do not have unique access to an unpredictable data stream to harvest for randomness. Any candidate (such as block headers) source of randomness is accessible to all DApp functions and can also be manipulated to an extent by miners.

\textsf{Fomo3D} is an example of a game style (known as \textsf{Exit Scam}\footnote{\url{https://exitscam.me/play}}) not based on random outcomes, and it is the most active game on Ethereum in our sample. The aim of this game is to be the last person to have purchased a ticket when a timer goes to zero in a scenario where anyone can buy a ticket and each purchase increases the timer by 30 seconds. Many speculated such a game would never end but on August 22, 2018, the first round of the game ended with the winner collecting 10,469 Ether\footnote{The first winner of Fomo3D, won 10,469 Ether \url{ https://etherscan.io/tx/0xe08a519c03cb0aed0e04b33104112d65fa1d3a48cd3aeab65f047b2abce9d508}} equivalent to \$2.1M USD at the time.
Blockchain forensics indicate a sophisticated winning strategy to front-run new ticket purchases~\cite{fomo3dhacker} that would reset the counter. The winner appears to have started by deploying some high gas consumption DApps unrelated to the game. When the timer of the game reached about 3 minutes, the winner bought 1 ticket and then sent multiple high gasPrice transactions to her own DApps. These transactions congested the network and bribed miners to prioritize them ahead of any new ticket purchases in \textsf{Fomo3D}.

% Is this the same as order flooding in HFT?

% = = =

\subsection{Name Services.}\label{sec:ens}

The final category in Table~\ref{tab:top25DApps} is name services, which are primarily aimed at displacing central parties involved in web domain registration (\eg ICAAN and registrars) and resolution (\eg DNS). For simple name services (such as some academic work like Ghazal~\cite{moosavighazal}), domains purchases are transactions and network monitors can front-run other users attempting to register domains. This parallels front-running attacks seen in regular (non-blockchain) domain registration~\cite{sac022en33:online}. \textsf{Ethereum Name Service (ENS)}\footnote{\url{https://ens.domains/}} is the most active naming service on Ethereum. Instead of allowing new \texttt{.eth} domain names to be purchased directly, they are put up for a sealed bid auction which seals the domain name in the bids, but not the bid amounts. The most common way of getting a domain is to call \texttt{startAuctionsAndBid()} in ENS auction smart contract, which leaks the hash of the domain name and the initial bid amount in the auction. Users are allowed to bid for 48 hours before the 48-hour reveal phase begins, in which bidders must send a transaction to reveal their bids for a specific domain in the auction. It is possible for a user to front-run other bids with the same bid amount by revealing first. The auction model is similar to crypto-collectibles auctions in \ref{sec:cryptogames}.

%% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = ICOs
% = = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Cases of Front-running in ICOs}  \label{sec:ICOsfrontrunning}

Initial coin offerings (ICOs) have changed how blockchain firms raise capital. More than 3000 ICOs have been held on Ethereum, and the market capitalization of these tokens appear to exceed \$75B USD in the first half of 2018~\cite{zetzsche2018ico}. At the DApp level, tokens are offered in short-term sales that see high transaction activity while the sale is on-going and then ICO activity tapers off to occasional owner transfers. When we collected the top 25 most active DApps on \texttt{DAppRadar.com}, no significant ICOs were in the initial sale stage. Despite the ICO category falls through our sampling method, we identify it as a major category of DApp and study it here.

\subsection{\textit{Status.im} ICO}
To deal with demand, ICOs cap sales in a variety of ways to mitigate front-running attacks. In June 2017, \textit{Status.im}~\cite{statuswhitepaper} started its ICO and reached the predefined cap within 3 hours, collecting close to 300,000 Ether. In order to prevent wealthy investors purchasing all the tokens and limit the amount of Ether deposited in each investment, they used a \textit{fair} token distribution method called \textit{Dynamic Ceiling} as an attempt to increase the opportunity for smaller investors. They implemented multiple caps (ceilings) in which, each had a maximum amount that could be deposited in. In this case, every deposit was checked by the smart contract and the exceeding amount was refunded to the sender while the accepted amount was sent to their multi-signature wallet address~\cite{statusicoanalysis}.

During the time the ICO was open for participation, there were reports of Ethereum network being unusable and transactions were not confirming. Further study showed that some mining pools might have been manipulating the network for their own profit. In addition, there were many transactions sent with a higher gas price to front-run other transactions, however, these transactions were failing due to the restriction in the ICO smart contract to reject any transactions with higher than 50 \textit{GWei} gas price (another mitigation against front-running).

\begin{figure}[t]
\centering
\includegraphics[width=0.5\linewidth]{figures/Mining_pool_ratio.png}
\caption{ The percentage of Ethereum blocks mined between block 3903900 and 3908029, this is the time frame in which Status.im ICO was running. This percentage roughly shows the hashing power ratio each miner had at that time. \label{fig:mining_pool_ratio}} % IS THIS STATEMENT CORRECT?
\end{figure}

\subsection{Data Collection and Analysis}
According to analysis we carried out, we discovered that the F2Pool---an Ethereum mining pool that had around 23\% of the mining hash rate at the time (Figure~\ref{fig:mining_pool_ratio})---sent 100 Ether to 30 new Ethereum addresses before the Status.im ICO started. When the ICO opened, F2Pool constructed 31 transactions to the ICO smart contract from these new address, without broadcasting the transactions to the network. They used their entire mining power to mine their own transactions and some other potentially failing high gas price transactions.

Ethereum's blockchain contains all transaction ever made on Ethereum. While the default client and online blockchain explorers offer some limited query capabilities, in order to analyze this case, we built our own database. Specifically, we used open source projects such as Go Ethereum implementation\footnote{Official Go implementation\url{https://github.com/ethereum/go-ethereum}} for the full node, a python script for extracting, transforming and loading Ethereum blocks, named \texttt{ethereum-etl}~\cite{ethereumetl} and Google BigQuery.\footnote{\url{https://cloud.google.com/bigquery/}} Using this software stack, we were able to isolate transactions within the Status.im ICO. We used data analysis tool \texttt{Tableau}.\footnote{\url{https://www.tableau.com/}} A copy of this dataset and the initial findings can be found in our Github repository.\footnote{\url{github.com/} Removed for anonymity.}

As shown in Figure~\ref{fig:Transactions_miners_while_status_ico_cut}, most of the top miners in the mentioned time frame, have mined almost the same number of failed and successful transactions which were directed toward Status.im token sale, however F2Pool's transactions indicate their successful transactions were equivalent to 10\% of the failed transactions, hence maximizing the mining rewards on gas, while censoring other transactions to the token sale smart contract. The terminology used here is specific to smart contract transactions on Ethereum, by \textit{``failed transaction''} we mean the transactions in which the smart contract code flow rejected and threw an exception and by \textit{``successful transaction''} we mean the transactions that went through and received tokens from the smart contract.


\begin{figure}[t]
\centering
\includegraphics[width=0.7\linewidth]{figures/Transactions_miners_while_status_ico_cut_only_icotx.png}
\caption{ This chart shows the miners behaviour on the time window that Status.im ICO was running. It is clear that the number of successful transactions mined by F2Pool do not follow the random homogeneous pattern of the rest of the network. \label{fig:Transactions_miners_while_status_ico_cut}}
\end{figure}

% make pie charts for each mining pool, all non-status-ico transactions vs success-ico-transactions vs failed-ico=transactions

\begin{figure}[t]
\centering
\includegraphics[width=0.6\linewidth]{figures/F2Pool_transactions_to_StatusICO_and_Refunds.png}
\caption{ F2Pool prior to Status.im ICO deposited 100 Ether in multiple new Ethereum addresses. On the time of the ICO they sent these deposits to Status ICO smart contract and prioritized mining of these transactions in their mining pool, this was to overcome the dynamic ceiling algorithm of the token sale smart contract. Later on they sent the refunded Ether back to their own address. [Graph made using Blockseer.com] \label{fig:f2poolfront-run}}
\end{figure}

By tracing the transactions from these 30 addresses, we found explicit interference by the F2Pool\footnote{F2Pool Ethereum address was identified by their mining reward deposit address \url{https://etherscan.io/address/0x61c808d82a3ac53231750dadc13c777b59310bd9}} in this scenario. As shown in Figure~\ref{fig:f2poolfront-run}, the funds deposited by F2Pool in these addresses were sent to Status.im ICO and mined by F2Pool themselves, where the dynamic ceiling algorithm refunded a portion of the deposited funds back to these addresses, these funds were sent back to F2Pool main address a few days after and the tokens were aggregated later on in one single address. Although this incident does not involve transaction reordering in the blocks, it shows how miners can modify their mining software to behave in a certain way to front-run other transactions and gain monetary profit.


% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Mitigations
% = = = = = = = = = = = = = = = = = = = = = = = = = = %


\section{Key Mitigations} %We have the applicability of the solutions inline.


%\begin{figure}[t]
%\centering
%\includegraphics[width=0.7\linewidth]{figures/solutions_mindmap.png}
%\caption{ \emph{Solutions Mindmap}  \label{fig:solutions_mindmap.png}}
%\end{figure}
%https://drive.mindmup.com/map/1u27BpAgU2CVy4BUf33cTRsOzJ01W3Gl2


As we studied front-running attacks on blockchain, we also encountered a number of ways of preventing, detecting, or mitigating front-running attacks. Instead of providing the details of exact solutions which will change over time, we extract the main principles or primitives that address the attack. A particular system may implement more in a layered mitigation approach.

We classify the mitigations into three main categories. In the first category, the blockchain removes the miner's ability to arbitrarily order transactions and tries to enforce some ordering, or queue, for the transactions. In the second category, cryptographic techniques are used to limit the visibility of transactions, giving the potential front-running less information to base their strategy on. In the final category, dapps are designed from the bottom-up to remove the importance of transaction ordering or time in their operations. We also note that for dapps that are legally well-formed (\eg with identified parties and a clear jurisdiction), front-running attacks can violate laws, which is its own deterrent. We do not discuss this further here; see Appendix ~\ref{app:traditionalprevention}.

%\subsection{Front-Running Resistant Blockchains}
\subsection{Transaction Sequencing}

Ethereum miners store pending transactions in pools and draw from them when forming blocks. As the term `pool' implies, there is no instinct order to how transactions are drawn from the pool and miners are free to sequence them arbitrarily.\footnote{Sometimes the pool is called a `queue.' It is important to note is a misnomer as queues use a first-in-first-out sequence.} This enables certain kinds of front-running, in particular transactions the miner will place before a pending transaction\footnote{The vanilla Go-Ethereum implementation, prioritizes transactions based on their gas price and nonce~\cite{EthMinerTxOrder}}. A number of proposals attempt to thwart this attack by enforcing a rule about how to sequence transactions.

First-in-first-out (FIFO) is generally not possible on a distributed network because transactions can reach different nodes in a different order. While the network could form a consensus based on locally observed FIFO, this would increase the rate of orphaned blocks, as well as adding complexity to the protocol. A trusted third party could be used to assign sequential numbers to transactions (and sign them), but this is contrary to the blockchain's core innovation of distributed trust. None the less, some exchanges will centralize time-sensitive functionalities (\eg  \textit{EtherDelta} and \textit{0xProject}) in off-chain order books~\cite{warren20170x,0xfrontrunning:online}).

An alternative is to sequence transactions psuedorandomly. This can be seen in proposals like Canonical Transaction Ordering Rule (CTOR) by Bitcoin Cash ABC~\cite{bitcoincashabcFork} which adds transactions in lexicographical order according to their hash~\cite{bitcoinABC2018CTOR}. Note that Bitcoin does not have a front-running problem for most standard transactions. While this could be used by Ethereum to make front-running statistically difficult, the protection is marginal at best and might even exacerbate attacks. A front-runner can construct multiple equivalent transactions, with slightly different values, until she finds a candidate that positions her transaction a desirable location in the resulting sequence. She broadcasts only this transaction and now miners that include her transaction will position it in front of transactions they heard about much earlier. 


Finally, transactions themselves could enforce order. In particular, they could point to the current state of the contract and only execute on that exact state. This transaction chaining only prevents certain sub-types of front-running. For example, it could prevent scalping attacks: if Alice buys from a marketplace that matches her order to Bob with a price improvement, a miner could buy from Bob first and then execute Alice's original transaction which results in her being matched to Alice instead. By contrast, if Alice registers an interesting-looking domain name, transaction chaining does not stop a miner from replacing Alice's request with her own. Transaction chaining would likely lead to more orphaned transactions for active contracts, as only one state-changing transaction would be allowed per state.

%\paragraph{Design Decision \#1: Fixed Transaction Ordering.} da Silva~\etal~\cite{fixedordering2018silva} proposes an algorithm, known as Fixed Transaction Ordering and Admission (FTOA), in the consensus protocol that enforces the order of the transactions in the mined blocks, using logical timestamps in a Byzantine setting, to eliminate transaction reordering by miners. This is a theoretical solution and is not trivial to implement in the current Byzantine consensus protocols.

\subsection{Confidentiality}

\paragraph{Privacy-Preserving Blockchains.}

All transaction details in Bitcoin are make public and participant identities are only lightly protected. A number of techniques increase confidentiality~\cite{bunzBulletproofs,maxwell2015confidential} and anonymity [zerocoin, monero, etc] for cryptocurrencies. A current research direction is extending these protections to DApps. It is tempting to think that a confidential DApp would not permit front-running, as the front-runner would not know the details of the transaction she is front-running. However there are some nuances here to explore.

A DApp includes the following components: (1) the code of the DApp, (2) the current state of the DApp, (3) the name of the function being invoked, (4) the parameters supplied to the function, (5) the address of the contract the function is being invoked on, and (6) the identity of the sender. Confidentiality applied to a DApp could mean different levels of protection for each of these. For front-running, function calls (3,4) are the most important, however function calls could be inferred from state changes (2). Hawk~\cite{kosba2016hawk} and Eiden [c] are examples of (2,3,4)-confidentiality (with limitations we are glossing over).

The applicability of privacy-preserving blockchains needs to be evaluated on a case-by-case base. For example, one method used by traditional financial exchanges in dealing with front-running from high frequency traders is a dark market: essentially a (2,3,4)-confidential order book maintained by a trusted party. A DApp could disintermediate this trusted party. Users whose balances are effected by changes in the contract's state would need to be able to learn this information. Further, if the contract addresses are known (no 5-confidentiality), front-runners can know about the traffic pattern of calls to contracts which could be sufficient grounds for attack; for example, if each asset on an exchange has its own market contract, this leaks trade volume information. As a contrasting example, consider again decentralized domain registration: hiding state changes (2-confidentiality) defeats the entire purpose of the DApp, and protecting function calls is ineffective with a public state change since the state itself reveals the domain being registered.

%Privacy-preserving blockchains strive (to some extent~\cite{miller2017empirical,kappos2018empirical}) to keep all details of transactions private, including participants and amounts. As an example, ZCash~\cite{hopwood2016zcash} uses two distinct types of addresses, transparent and shielded addresses. Transparent addresses work similar to Bitcoin transactions, fully transparent about the sender and receiver addresses, the amount and included data. However, shielded addresses are private and do not leak any information. While this solution works for simple transactions, building similar shields for DApps is subject to on-going research~\cite{}. With the possibility of having private smart contracts in such a setting, it could be feasible to achieve a front-run resistance blockchain, however, the functionality of the smart contracts could be limited.


\paragraph{Commit/Reveal.}
\label{sec:comm}

While confidentiality appears insufficient for solving domain name front-running alone, a hybrid approach of sequencing and confidentiality can be effective, and is in fact an example of an older cryptographic trick known as commit/reveal. The essence of the approach is to protect the function call (\eg (3,4)- or (4)-confidentiality) until the function is enqueued in sequence of functions to be executed. Once the sequence is established, the confidentiality is lifted and the function can only be executed in the place is was given (or, generally speaking, not at all).

Recall that a commitment scheme enables one to commit to a digital value (\eg a statement, transaction, data, \etc) while keeping it a secret (\textit{hiding}), and then open it (and only it: \textit{binding}) at a later time of the committer's choosing~\cite{brassard1988minimum}. A common approach (conjectured to be hiding) is to submit the cryptographic hash of the value with a random nonce (for low entropy data) to a smart contract, and later reveal the original value and nonce which can be verified by the contract to correctly hash to the commitment (see Figure~\ref{fig:commitReveal} in Appendix~\ref{app:cr}).

An early application of this scheme to blockchain is Namecoin, a Bitcoin-forked DApp for name services~\cite{kalodner2015empirical}. In Namecoin, a user sends a commit transaction which registers a new hidden domain name, similar to a sealed bid. Once this first transaction is confirmed, a time delay begins. After the delay, a second transaction reveals the details of the requested domain. This prevent front-running if the reveal transaction is confirmed faster than an adversarial node or miner can redo the entire process.

Commit/reveal is a two round protocol, and aborting after the first round (early aborts) could be an issue for this (along with most multi-round cryptographic protocols). For example, in a financial exchange where the number of other orders might be in a predictable interval, an adversary can spray the sequence (\ie a price-time priority queue) with multiple committed transactions and no intention of executing them all. She then only reveal the ones that result in an advantageous trade.\footnote{This is analogous to behaviour in traditional financial markets where high frequency traders will make and cancel orders at many price points. If they can cancel faster than someone can execute it---someone who has only seen the order and not the cancelation---then the victim reveals their price information.} There are other ways of aborting; if payments are required but not collateralized, the aborting party can ensure that payment is not available for transfer. One mitigation to early aborts that blockchain is uniquely positioned to make is having users post a fidelity bond of a certain amount of cryptocurrency that can be automatically dispensed if they fail to fully execute committed transactions (this is used in multi-round blockchain voting~\cite{mccorry2017smart}). Finally we note that any multiple round protocol will have usability challenges: users must be aware that participating in the first round is not sufficient for completing their intention.

% Jeremy: doesn't seem related to front-running
%Commit/reveal is also seen in on-chain voting~\cite{adChainPLCRVoting}. Using sealed votes, voters can assure their votes are hidden until a later date, however, their participation and weight of the vote are publicly known.

% Jeremy: moved up to confidentiality as this is not specific to commit/reveal but applicable to any mitigation
%The participatory factor is another issue for the commitment scheme. For anyone watching the DApp address, there will be a direct transaction from the user to the DApp address, revealing the fact that a specific address has participated in the auction or the DApp using a commit and reveal scheme, but the details are hidden through the scheme. Both these issues, albeit hiding the details of the order and preventing direct front-running, leak information to other participants which could lead to more sophisticated front-running attacks depending on the application design. On the other note, these method has some drawbacks, the user experience is not smooth and one might forget to reveal the committed transaction. In the ENS commit-reveal process, if one forgets to reveal in the reveal phase, the committed funds are burnt and inaccessible thereafter. Also, this scheme means two transactions are required for a functionality which makes it more expensive.

\begin{figure}[t]
\centering
\includegraphics[width=0.5\linewidth]{figures/LibSubmarine.png}
\caption{Submarine Send~\cite{libsubmarine}. User generates an \textit{Unlock} transaction from which the commitment address is retrieved. By funding the \textit{commitment address}, user is committed to the unlock transaction. After the commitment transaction, in the reveal phase, user sends the \textit{reveal transaction} to the DApp and then after she can broadcast the Unlock transaction to unlock the funds in the commitment address. Finally after the "Auction'' is over, anyone can call \textit{Finalize} function to finalize the process.  \label{fig:LibSubmarine}}
\end{figure}
%https://www.lucidchart.com/invitations/accept/3a259b74-1162-4fb5-8023-eb0311018295

\paragraph{Enhanced Commit/Reveal.} Submarine Commitments~\cite{breidenbach2018enter,submarinesendHD} extend basic commit/reveal functionality with additional properties for Ethereum smart contracts: (1) they initially hide the contract address being invoked, providing (3,4,5)-confidentiality during the commit phase; and (2) they ensure that if a revealed transaction sent funds, the funds were fully collateralized at commit time and are available to the receiving smart contract.

% Jeremy: Merge this into the caption so there is one stand-alone description
%With submarine send, it is possible to hide sender, receiver, value, and data, so the commitment transaction is identical to a transaction to a newly generated address. Submarine sends could be a solution for sealed-bid auctions on the blockchain to hide the existence of the bids for other participants. The details of how Submarine commitments work could fill an entire paper, however in short, using the way Ethereum transactions are constructed and ECDSA ECRecover functionality, it is possible to generate one outgoing transaction from an address of which no private key exists. By constructing a transaction from that address to the DApp and funding that address we fulfill the commitment phase. By revealing the details and broadcasting the constructed transaction we reveal the commitment~\cite{libsubmarine}. See Figure~\ref{fig:LibSubmarine}. However, this could be designed in other ways to suit the need of the DApp. Drawbacks of this scheme are similar to commit/reveal, with the addition of two more transactions to finalize a transaction, which adds cost and complexity to the user experience.

\subsection{Design Practices}

The final main category of mitigation is to assume front-running is unpreventable and to thus responsively redesign the functionality of the DApp to remove any benefit from front-running. For example, when designing a decentralized exchange, one can use a call market design instead of a time-sensitive order book~\cite{clark2014decentralizing} to side-step and disincentivize front-running by miners. In a call market design, the arrival time of orders does not matter as they are executed in batches. The call market solution pivots profitable gains that front-running miners stand to gain into fees that they collect~\cite{clark2014decentralizing}, removing the financial incentive to front-run. 

% Jeremy: This needs some clarification; what exactly is the principle they are applying???
Malinova and Park discuss different design settings for financial markets and trading platforms on decentralized ledgers~\cite{malinova2017market}. They argue that blockchain brings new options of transparency which affects traders behaviour, especially in the presence of intermediary front-runners. They model indirect trading costs and use the economic literature on search and trading at decentralized exchanges in their design settings to make front-running costly and inefficient. Specifically they use economic models in their trading market design to make front-running expensive and more costly than profitable. They split big investments into smaller ones using intermediaries --liquidity demander-- and liquidity providers to achieve this.

% one solution could be to remove multiple actors, meaning that on each "play" (order), the smart contract would be the market maker. it does not matter if there are multiple similar orders. similar to PoC of Velocity~\cite{eskandari2017feasibility}. Although there are other concerns about this specific design but not for front-running.

%TODO: inline talk about what these solutions are good for and if they fit Status ICO

% = = = = = = = = = = = = = = = = = = = = = = = = = = %
% = = = Conc
% = = = = = = = = = = = = = = = = = = = = = = = = = = %

\section{Concluding Remarks}

Front-running is a pervasive issue in Ethereum DApps. While some DApp-level application logic could be built to mitigate these attacks, its ubiquity across different DApp categories suggests mitigations at the blockchain-level would perhaps be more effective. We highlight this as an important research area.

% Could talk about future work on a tool / a framework to detect front-running
